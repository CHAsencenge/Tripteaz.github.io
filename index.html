<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>CHAsencenge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="CHAsencenge">
<meta property="og:url" content="https://chasencenge.github.io/Tripteaz.github.io/index.html">
<meta property="og:site_name" content="CHAsencenge">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="CHAsencenge">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/Tripteaz.github.io/atom.xml" title="CHAsencenge" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/Tripteaz.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/Tripteaz.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/Tripteaz.github.io/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Tripteaz.github.io/" id="logo">CHAsencenge</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/Tripteaz.github.io/">Home</a>
        
          <a class="main-nav-link" href="/Tripteaz.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/Tripteaz.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chasencenge.github.io/Tripteaz.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Rendering/RenderingTheory_色彩空间" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/" class="article-date">
  <time class="dt-published" datetime="2023-01-04T06:21:39.000Z" itemprop="datePublished">2023-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Tripteaz.github.io/categories/Rendering/">Rendering</a>►<a class="article-category-link" href="/Tripteaz.github.io/categories/Rendering/Theory/">Theory</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/">【Theory】 色彩空间</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>关于标准</strong></p>
<p>SDR通常使用sRGB&#x2F;BT.709, BT.601；HDR通常使用BT.2020, DCI-P3, sRGB(for gaming)，在DX12中体现为色彩空间枚举内容的一部分。</p>
<p><strong>Blending表现上</strong></p>
<p>Perceptual blend模仿人类对颜色的感知，平滑过渡。</p>
<p>Linear blend基于光的物理行为来混合颜色。如相机中的焦距模糊将颜色混合在一起，在远处观看两种颜色的图案。</p>
<p>sRGB blend是计算机软件中混合颜色的方式，表现上是混合时发暗发蓝，历史包袱是CRT显示器的工作方式。</p>
<p><strong>颜色感知</strong></p>
<p>需要对光谱进行复杂的非线性转换，已有相应的模型；眼睛是不能感知全光谱的光的，视锥细胞（cones）是对颜色有感知反应细胞，会对一定范围内的波长做出反应，cones依据感知波长区间敏感度来分类：长，中，短，LMS；长对应红色，中到绿色，短到蓝色（红色波长最长，蓝色最短）。</p>
<p>只要响应相同，不同光谱可以产生相同的“感知颜色”。例如，彩色显示器通过结合红色、绿色和蓝色的光产生广泛的颜色。印刷作品类似地使用青色、品红和黄色墨水，彩色涂料是通过混合各种颜料来达到所需的颜色。</p>
<p>色调、亮度、色彩等其实不是光的基本属性，它们的数值模拟是经验拟合的非线性模型。</p>
<p><strong>数学方法描述</strong></p>
<p>三种原色组合，CIE 1931 XYZ颜色空间将颜色表示为三个值:X、Y和Z。</p>
<p><strong>什么是色彩空间</strong></p>
<p>将颜色映射到数字，进行描述需要一组基色（primary color）集合，和一个非线性转换函数（transfer function）。</p>
<p>常用的Transfer function的形式是<br>$$<br>f(x) &#x3D; x^γ， γ &#x3D; 1&#x2F;2.2<br>$$<br><strong>色域&#x2F;色饱和度</strong></p>
<p>选择的原色影响了可见颜色的哪部分可被表示，能被表示的部分为色域（gamut）。</p>
<p>色域之外的许多颜色仍然是有效的颜色，它们只是不能在给定的色彩空间中进行编码。</p>
<p><strong>不能被编码的颜色</strong>可以分两类：</p>
<p>一个或多个RGB值大于1，但没有负值：这些颜色对于色彩空间来说太亮了，但是可以在较低的亮度下进行编码。</p>
<p>一个或多个负数：这些颜色比色彩空间能够编码的颜色更丰富多彩。其中一些可以是真实的颜色，但也可以是比物理可能的颜色更丰富的颜色。这是颜色线性编码的结果，它能够编码现实生活中不存在的颜色。</p>
<p>更宽的色域需要更高数据精度存储颜色，普通显示器可能无法显示所有颜色。</p>
<p><strong>色彩管理</strong></p>
<p>对色彩空间的信息进行编码，将颜色转换为设备的正确色彩空间。</p>
<p>不主动管理颜色的应用程序，sRGB已成为标准。</p>
<p><strong>色彩操作</strong></p>
<p>有意义的有三类：</p>
<p>符合真实光照和材料的行为。</p>
<p>与人对色彩感知相匹配。</p>
<p>风格化。</p>
<p><strong>色彩比较</strong></p>
<p>sRGB和Linear都不能做到和色调感知一致的有色与白色的混合。</p>
<p>混合饱和相反的颜色时，sRGB表现为变暗。</p>
<p>混合黑白，sRGB和感知色彩空间差不多。</p>
<p><strong>HSL&#x2F;HSV</strong></p>
<p>色调、饱和度、亮度&#x2F;值。</p>
<p>它们不是颜色空间，是将RGB颜色空间重新映射到更容易使用的参数的方法。</p>
<p>因此它们共享它们所基于的RGB颜色空间的属性。</p>
<p><strong>Ref：</strong></p>
<p><a target="_blank" rel="noopener" href="https://bottosson.github.io/posts/colorwrong/">How software gets color wrong</a></p>
<p><a target="_blank" rel="noopener" href="https://bottosson.github.io/posts/gamutclipping/">sRGB gamut clipping</a></p>
<p><a target="_blank" rel="noopener" href="https://indico.freedesktop.org/event/2/contributions/56/attachments/64/105/2022%20XDC%20Is%20HDR%20Harder.pdf">AMD: Is HDR Harder？</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chasencenge.github.io/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/" data-id="clcha9ctq0000csypcrj06va5" data-title="【Theory】 色彩空间" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Essay/CountDown_JobHopping209" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping209/" class="article-date">
  <time class="dt-published" datetime="2023-01-04T03:32:25.000Z" itemprop="datePublished">2023-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Tripteaz.github.io/categories/Essay/">Essay</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping209/">CD_JH_209</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        Here's something encrypted, password is required to continue reading.
        
          <p class="article-more-link">
            <a href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping209/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://chasencenge.github.io/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping209/" data-id="clch9pny000006kyp9iqphz8n" data-title="CD_JH_209" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Essay/CountDown_JobHopping210" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping210/" class="article-date">
  <time class="dt-published" datetime="2023-01-04T03:31:50.000Z" itemprop="datePublished">2023-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Tripteaz.github.io/categories/Essay/">Essay</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping210/">CD_JH_210</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        Here's something encrypted, password is required to continue reading.
        
          <p class="article-more-link">
            <a href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping210/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://chasencenge.github.io/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping210/" data-id="clch9pny300016kypeheu5nt8" data-title="CD_JH_210" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Rendering/RenderingTheory_HZB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/" class="article-date">
  <time class="dt-published" datetime="2023-01-04T02:29:43.000Z" itemprop="datePublished">2023-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Tripteaz.github.io/categories/Rendering/">Rendering</a>►<a class="article-category-link" href="/Tripteaz.github.io/categories/Rendering/Theory/">Theory</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/">【Rendering】 遮挡剔除与层次Z缓冲（上）——原理篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p><strong>遮挡剔除（Occlusion Culling，OC）</strong>属加速算法，用于剔除从视点看向场景时的被遮蔽的物体，减少不必要的渲染开销。</p>
<p><strong>层次Z缓冲（Hierarchical Z-Buffering，HZB）</strong>是GPU实现z-culling的硬件方法的基础。</p>
<h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h4><h5 id="2-1-z-buffer和z-culling"><a href="#2-1-z-buffer和z-culling" class="headerlink" title="2.1 z-buffer和z-culling"></a>2.1 z-buffer和z-culling</h5><p>在管线中，当一个物体投射到屏幕，像素深度值会和buffer中已存的深度值进行比较，这一过程叫做深度测试，若新的深度值更小，则取代buffer中的旧值。场景中所有物体会执行这一过程，得到最终更新后的z-buffer，这一过程叫做z-culling。</p>
<h5 id="2-2-depth-complexity"><a href="#2-2-depth-complexity" class="headerlink" title="2.2 depth complexity"></a>2.2 depth complexity</h5><p>指单一像素点覆盖了多少层物体表面，注意这里是surface layer的概念，例如下图中间像素的depth complexity &#x3D; 10，因为因为穿过了10个sphere的表面（假设backface culling开启，不算背面）。</p>
<img src="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/hzb0.png" class title="This is an image">



<h4 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h4><p>动机在于<strong>像素着色次数</strong>，<strong>无效三角形是否被光栅化</strong>，<strong>深度计算和比较深度次数</strong>。</p>
<p>对于back-to-front渲染，对于上图中的10个sphere，会从最后面的sphere开始完整的执行像素着色，对于单个像素而言，中间像素着色10次。</p>
<p>对于front-to-back渲染，尽管省去了重复pixel shading的开销，但10个sphere表面上的三角形仍然经历了光栅化，也依次执行了深度计算的深度测试。</p>
<p>OC的引入使得被遮蔽的物体直接不传入渲染管线，能够规避更多的无谓开销。</p>
<h4 id="4-遮挡剔除算法"><a href="#4-遮挡剔除算法" class="headerlink" title="4. 遮挡剔除算法"></a>4. 遮挡剔除算法</h4><h5 id="4-1-可见性判断划分"><a href="#4-1-可见性判断划分" class="headerlink" title="4.1 可见性判断划分"></a>4.1 可见性判断划分</h5><p>根据viewing location形式来划分，对于可见性的确定可以是<strong>point-based</strong>的，也可以是<strong>cell-based</strong>的。</p>
<img src="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/hzb1.png" class title="This is an image">



<p>point-based visibility仅考虑单个的viewing location，cell-based visibility考虑的是viewing locations的集合，视点在集合中的任意位置时是否可见。</p>
<p>cell-based的用途是得到的结果可以供多帧来使用，只要viewer还在cell内，但因为计算过程较为耗时，如果使用一般作为预处理步骤（preprocessing step）。</p>
<h5 id="4-2-通用算法流程"><a href="#4-2-通用算法流程" class="headerlink" title="4.2 通用算法流程"></a>4.2 通用算法流程</h5><p>初始化occlusion representation，记为O，存有遮蔽信息。</p>
<p>对于场景中的每个物体g：</p>
<p>进行可见性测试（visibility test），如果不可见，忽略；如果可见，把g送入渲染流程，将g添加到potential occluders集合P。</p>
<p>每当P中potential occluders达到一定数量，将其中元素的遮蔽信息merge到O（这样P中的每个物体也成为了occluder）。</p>
<h5 id="4-3-Tips"><a href="#4-3-Tips" class="headerlink" title="4.3 Tips"></a>4.3 Tips</h5><p>绘制顺序对最终性能表现有影响，最好是先sorting，再front-to-back绘制。</p>
<p>由于距离的影响，很小的object也可能成为巨大的occluder（一叶障目）。</p>
<h4 id="5-GPU对OC的支持（Occlusion-Query）"><a href="#5-GPU对OC的支持（Occlusion-Query）" class="headerlink" title="5. GPU对OC的支持（Occlusion Query）"></a>5. GPU对OC的支持（Occlusion Query）</h4><h5 id="5-1-用户向GPU询问什么"><a href="#5-1-用户向GPU询问什么" class="headerlink" title="5.1 用户向GPU询问什么"></a>5.1 用户向GPU询问什么</h5><p>一个三角形集合（对比当前z-buffer）是否可见。这里的三角形通常指物体的bounding volume，如果这些三角形都不可见（实际上一般是<strong>三角形所占的像素数量n&lt;某阈值</strong>，这个n也可以用来决定物体的LOD），那么包围的物体就可以被剔除。</p>
<h5 id="5-2-GPU在这一过程中做了什么"><a href="#5-2-GPU在这一过程中做了什么" class="headerlink" title="5.2 GPU在这一过程中做了什么"></a>5.2 GPU在这一过程中做了什么</h5><p>将query的（组成BV的）三角形集合光栅化，将它们的深度与z-buffer比较（因此操作是在<strong>image space</strong>中完成的，也是后面HZB的基础）。</p>
<h5 id="5-3-Gain-Cost"><a href="#5-3-Gain-Cost" class="headerlink" title="5.3 Gain-Cost"></a>5.3 Gain-Cost</h5><p>如果结果是将物体剔除，那么收益来自于将此物体从渲染管线中排除，如果结果是物体可见，那么多了此次检测的开销，这自然引入一个问题：什么时候”值得“query。</p>
<h5 id="5-4-什么时候”值得“query"><a href="#5-4-什么时候”值得“query" class="headerlink" title="5.4 什么时候”值得“query"></a>5.4 什么时候”值得“query</h5><p>通常一次query的latency时间大概可渲染数百至数千的三角形，当一个bounding volume包含大量的物体并且有相对较多数量的遮蔽发生时，Gain-to-Cost会更高。</p>
<h5 id="5-5-GPU的-occlusion-query-model"><a href="#5-5-GPU的-occlusion-query-model" class="headerlink" title="5.5 GPU的 occlusion query model"></a>5.5 GPU的 occlusion query model</h5><p>CPU发送任意数量的query，然后CPU周期性检查是否获得query结果，这一过程是异步的。GPU在这一过程执行query并将结果放到一个队列，由CPU去查询结果。DX和GL提供的occlusion query接口是predicated&#x2F;conditional的，query和draw call ID一起提交，如果结果是可见的，GPU自动处理draw call。</p>
<h5 id="5-6-优化"><a href="#5-6-优化" class="headerlink" title="5.6 优化"></a>5.6 优化</h5><p>Occlusion Query其实应该施加在更可能被遮蔽的那些物体上，类似于局部性原理，通常认为可见的倾向于保持可见，这些物体可降低检测频率（temporally jittered sampling），不可见的倾向于保持不可见，这类物体每帧执行检测。</p>
<p>occlusion query batching同时将一个大的BV细分。</p>
<h4 id="6-层次Z缓冲"><a href="#6-层次Z缓冲" class="headerlink" title="6. 层次Z缓冲"></a>6. 层次Z缓冲</h4><p>层次Z缓冲的实现基于GPU的Occlusion Query，因此也是在image space中完成。</p>
<h5 id="6-1-数据准备"><a href="#6-1-数据准备" class="headerlink" title="6.1 数据准备"></a>6.1 数据准备</h5><p>主要包括将场景模型保存在八叉树和z-pyramid构建。</p>
<p>在HZB中，场景模型保存在一个八叉树中，算法中遍历的单位是octree node。</p>
<img src="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/hzb2.png" class title="This is an image">

<p><strong>z-pyramid</strong>是指将一帧的z-buffer处理为一个图像金字塔（image pyramid），z-pyramid有层次概念，最高分辨率级别（finest level）其实就是标准的z-buffer，也就是金字塔底，然后向上依次降低分辨率，注意处理的方式并不是取平均，而是取2x2网格中的深度最大值（要这样设定的<strong>原因</strong>是，检测时会优先在低分辨率层级，也就是趋近金字塔顶的层级执行，在低分辨率层级中记录2x2网格最深的值，递推到金字塔顶，记录下来的就是最深的几个值，如果box的最近点比这个还远说明被遮蔽，向下检测同理），每当z-buffer中的z-value被覆写时，要沿z-pyramid的各个level递归传递更新。</p>
<img src="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/hzb3.png" class title="This is an image">

<h5 id="6-2-场景中遮挡区域的层次剔除"><a href="#6-2-场景中遮挡区域的层次剔除" class="headerlink" title="6.2 场景中遮挡区域的层次剔除"></a>6.2 场景中遮挡区域的层次剔除</h5><p>这一步的作用是让后续的测试能使用之前已渲染物体的遮蔽信息。</p>
<p>由于场景模型已保存在八叉树中，场景中遮挡区域的层次剔除由此八叉树支持。</p>
<p>以front-to-back方式遍历八叉树节点。</p>
<p>box投影到屏幕取最近点z<del>near</del>，和z-pyramid最顶（低分辨率）的层级单元比较深度，如果z<del>near</del>深度值更大，便可确定box被遮蔽。</p>
<p>终止条件是确定box被遮蔽，或者已经找到金子塔底box仍可见。</p>
<p>如果最终几何体确定是潜在可见的，那么渲染到hierarchical z-buffer（见上文4.2）</p>
<h5 id="6-3-HZB流程"><a href="#6-3-HZB流程" class="headerlink" title="6.3 HZB流程"></a>6.3 HZB流程</h5><p><strong>用已有遮蔽信息（z-buffer）生成z-pyramid</strong>，初始的遮蔽信息可由“best” occluders提供，什么是“best”呢，一般选择<strong>最近的n个</strong>objects组成的集合，或者<strong>人工生成</strong>的occluder primitives，或者使用<strong>上一帧</strong>的可视物信息（见6.2）。</p>
<p><strong>将物体的BV</strong>（通常用AABB, OBB, sphere）<strong>投影到screen space，根据公式估计对应的z-pyramid等级</strong>。投影后的最长边用于确定mip level，n代表总mip数，l是投影最长边长度（screen space）。</p>
<img src="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/hzb4.png" class title="This is an image">

<p>经过公式确定的层级，能够保证BV在相应的mip里最多覆盖2*2个深度值。</p>
<p>确定完要使用的z-pyramid层级后，<strong>用BV的z<del>min</del>（BV的最小深度值）和所覆盖的深度值（最多四个）比较，如果z<del>min</del>比所有值都大，被遮蔽</strong>。<strong>否则（z<del>min</del>比任一值小），不被遮蔽，需要渲染</strong>。</p>
<p>此外可以添加<strong>额外验证</strong>提高结果准确度，方法是存一个与一般z-pyramid恰好相反的，每层记录深度<strong>最小值</strong>的buffer，用z<del>max</del>和此buffer这一层对应位置上的各个深度比较，如果z<del>max</del>小于所有这些深度，那么是可见的。如果两次测试的结果（可见or不可见）不同，建议在更高分辨率级别继续测试。</p>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><p>Real-Time Rendering 4th Edition</p>
<p>Hierarchical Z-Buffer Visibility. Proceedings of SIGGRAPH ‘93. <em>Published February 1, 1993</em>. N. Greene, M. Kass, Gavin Miller.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chasencenge.github.io/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/" data-id="clch1p7nr0000l8ypgehy3zy4" data-title="【Rendering】 遮挡剔除与层次Z缓冲（上）——原理篇" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Tripteaz.github.io/categories/Essay/">Essay</a></li><li class="category-list-item"><a class="category-list-link" href="/Tripteaz.github.io/categories/Rendering/">Rendering</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/Tripteaz.github.io/categories/Rendering/Theory/">Theory</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Tripteaz.github.io/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/">【Theory】 色彩空间</a>
          </li>
        
          <li>
            <a href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping209/">CD_JH_209</a>
          </li>
        
          <li>
            <a href="/Tripteaz.github.io/2023/01/04/Essay/CountDown_JobHopping210/">CD_JH_210</a>
          </li>
        
          <li>
            <a href="/Tripteaz.github.io/2023/01/04/Rendering/RenderingTheory_HZB/">【Rendering】 遮挡剔除与层次Z缓冲（上）——原理篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 CHAsencenge<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/Tripteaz.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/Tripteaz.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/Tripteaz.github.io/js/jquery-3.4.1.min.js"></script>



  
<script src="/Tripteaz.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/Tripteaz.github.io/js/script.js"></script>





  </div>
</body>
</html>